{"ast":null,"code":"import jwt_decode from \"jwt-decode\";\nimport { refreshTokenAction } from \"../redux/actions/refreshTokenAction\";\nexport const tokenMiddleware = store => next => async action => {\n  if (action.meta && action.meta.requiresAuth) {\n    var _state$auth;\n    const state = store.getState();\n    const token = (_state$auth = state.auth) === null || _state$auth === void 0 ? void 0 : _state$auth.accessToken;\n    if (token) {\n      const expiresIn = jwt_decode(token).exp * 1000 - Date.now();\n      if (expiresIn < 1800000) {\n        const refreshToken = state.auth.refreshToken;\n        try {\n          await store.dispatch(refreshTokenAction(refreshToken));\n          const newToken = store.getState().auth.accessToken;\n          if (!newToken) {\n            throw new Error(\"Access token not found after refresh\");\n          }\n        } catch (error) {\n          store.dispatch({\n            type: \"LOGOUT\"\n          });\n        }\n      }\n    } else {\n      store.dispatch({\n        type: \"LOGOUT\"\n      });\n    }\n  }\n  return next(action);\n};","map":{"version":3,"names":["jwt_decode","refreshTokenAction","tokenMiddleware","store","next","action","meta","requiresAuth","_state$auth","state","getState","token","auth","accessToken","expiresIn","exp","Date","now","refreshToken","dispatch","newToken","Error","error","type"],"sources":["E:/SEM 4/MERN/end_sem_project/SocialEcho-main/client/src/middlewares/tokenMiddleware.js"],"sourcesContent":["import jwt_decode from \"jwt-decode\";\nimport { refreshTokenAction } from \"../redux/actions/refreshTokenAction\";\n\nexport const tokenMiddleware = (store) => (next) => async (action) => {\n  if (action.meta && action.meta.requiresAuth) {\n    const state = store.getState();\n    const token = state.auth?.accessToken;\n    if (token) {\n      const expiresIn = jwt_decode(token).exp * 1000 - Date.now();\n      if (expiresIn < 1800000) {\n        const refreshToken = state.auth.refreshToken;\n        try {\n          await store.dispatch(refreshTokenAction(refreshToken));\n          const newToken = store.getState().auth.accessToken;\n          if (!newToken) {\n            throw new Error(\"Access token not found after refresh\");\n          }\n        } catch (error) {\n          store.dispatch({ type: \"LOGOUT\" });\n        }\n      }\n    } else {\n      store.dispatch({ type: \"LOGOUT\" });\n    }\n  }\n  return next(action);\n};\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,YAAY;AACnC,SAASC,kBAAkB,QAAQ,qCAAqC;AAExE,OAAO,MAAMC,eAAe,GAAIC,KAAK,IAAMC,IAAI,IAAK,MAAOC,MAAM,IAAK;EACpE,IAAIA,MAAM,CAACC,IAAI,IAAID,MAAM,CAACC,IAAI,CAACC,YAAY,EAAE;IAAA,IAAAC,WAAA;IAC3C,MAAMC,KAAK,GAAGN,KAAK,CAACO,QAAQ,CAAC,CAAC;IAC9B,MAAMC,KAAK,IAAAH,WAAA,GAAGC,KAAK,CAACG,IAAI,cAAAJ,WAAA,uBAAVA,WAAA,CAAYK,WAAW;IACrC,IAAIF,KAAK,EAAE;MACT,MAAMG,SAAS,GAAGd,UAAU,CAACW,KAAK,CAAC,CAACI,GAAG,GAAG,IAAI,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;MAC3D,IAAIH,SAAS,GAAG,OAAO,EAAE;QACvB,MAAMI,YAAY,GAAGT,KAAK,CAACG,IAAI,CAACM,YAAY;QAC5C,IAAI;UACF,MAAMf,KAAK,CAACgB,QAAQ,CAAClB,kBAAkB,CAACiB,YAAY,CAAC,CAAC;UACtD,MAAME,QAAQ,GAAGjB,KAAK,CAACO,QAAQ,CAAC,CAAC,CAACE,IAAI,CAACC,WAAW;UAClD,IAAI,CAACO,QAAQ,EAAE;YACb,MAAM,IAAIC,KAAK,CAAC,sCAAsC,CAAC;UACzD;QACF,CAAC,CAAC,OAAOC,KAAK,EAAE;UACdnB,KAAK,CAACgB,QAAQ,CAAC;YAAEI,IAAI,EAAE;UAAS,CAAC,CAAC;QACpC;MACF;IACF,CAAC,MAAM;MACLpB,KAAK,CAACgB,QAAQ,CAAC;QAAEI,IAAI,EAAE;MAAS,CAAC,CAAC;IACpC;EACF;EACA,OAAOnB,IAAI,CAACC,MAAM,CAAC;AACrB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}